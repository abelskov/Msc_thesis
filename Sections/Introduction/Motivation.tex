%Problemet med sidekanaler (skal lede op til baggrundsafsnittet)
%Nævn evt. også noget om små devices.

% Motivation
While our conventional cryptography methods, such as AES (encryption), SHA-256 (hashing) and RSA/Elliptic Curve (signing) work well on systems with reasonable processing power and memory capabilities, these do not scale well into a world with embedded systems and sensor networks.
This introduces some challenges such as how to reduce the amount of costly operations whilst still guaranteeing the highest level of security. The limits related to physical size, processing power, memory and battery life call for more lightweight cryptography methods to be implemented on such systems.
Lightweight cryptography applications can be implemented in many programming languages, most of which still leave the devices open to more sophisticated hacking methods such as timing attacks.
These sophisticated hacks exploit weaknesses in physical "side-channels" and are, at least in theory, avoidable if we choose our language of implementation carefully.
We will expand on reversible computing first, and then come back to side-channels in chapter ~\ref{chapt - Side-channel}.

\section{Reversible Programming}
% NAND gates are irreversible.
% Landaurs principle is that heat must be generated when doing any "logically irreversible manipulation of information".

Reversible programming is a programming paradigm dating back to the early 1960s. Gordon Moore, the CEO of Intel, whose paper from 1965 describes a doubling of the number of transistors in a computers approximately every 18 months has led many people to believe that computing power would also double roughly every two years. This has been largely true until now, but researchers argue that this is ultimately going to come to an end unless we find a solution to overheating problems.

Rolf Landaur argues in \cite{Irreversibility_paper}that any irreversible operation must result in some kind of heat dissipation and that, theoretically, with reversible operations, if operation A pushes the machine from an original state into some new state, then operation A$^{-1}$ could use the already existing energy in the system to push it back to the original state.
Such a machine has not yet been invented, but reversible programming has other interesting properties.
As discussed in section \ref{chapt - Reversible-computing}, it can serve as protection against side-channel attacks and is also an interesting field to study to better understand quantum computing.

\section{Basis for the work}
This goal of this thesis is to further extend Hermes, which is a reversible programming language developed at DIKU.
Hermes is based on the reversible programming language Janus and designed specifically for writing encryption algorithms\cite{MogensenHermes}.
By virtue of some carefully thought-out design choices, Hermes offers a built-in protection against some side-channel attacks.

In the current implementation, Hermes programs are translated to C by the program \emph{hc} and then to assembly code with the GNU Compiler Collection (gcc). The gcc compiler does not prevent side-channel attacks per default, but one can use zerostack\cite{Github.zerostack} to zero out the stack and registers of sensitive functions.
There is also the problem of timing attacks introduced by gcc\cite{Simon2018}.
This compilation from Hermes to assembly is a two-step process with a required extra check by zerostack. But with embedded systems being the focus of these reversible lightweight cryptography algorithms, it seems appropriate with a compiler that translates Hermes directly to ARM64 assembly code.
It would also be appropriate to compile Hermes into a reversible intermediate language to allow for multiple assembly targets. We are going to be using a Reversible Single Static Assignment (RSSA) representation for this intermediate language.
