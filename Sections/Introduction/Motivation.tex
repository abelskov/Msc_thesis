%Problemet med sidekanaler (skal lede op til baggrundsafsnittet)
%Nævn evt. også noget om små devices.

% Motivation
While our conventional cryptography methods, such as AES (encryption), SHA-256 (hashing) and RSA/Elliptic Curve (signing) work well on systems with reasonable processing power and memory capabilities, these do not scale well into a world with embedded systems and sensor networks.
This introduces some challenges such as how to reduce the amount of costly operations whilst still guaranteeing the highest level of security. The limits related to physical size, processing power, memory and battery life call for more lightweight cryptography methods to be implemented on such systems.
Lightweight cryptography applications can be implemented in many programming languages, most of which still leave the devices open to more sophisticated hacking methods such as timing attacks. These side-channel vulnerabilities are, at least in theory, avoidable if we choose our language of implementation carefully.

\section{Reversible Programming}
% NAND gates are irreversible.
% Landaurs principle is that heat must be generated when doing any "logically irreversible manipulation of information".

Reversible programming is a programming paradigm from dating back to the early 1960s. Back then, R. Landaur saw that Moore's law about the number of transistors in a computer doubling approximately every two years and   were ultimately going to come to an end because of overheating problems.
He argued that any irreversible operation must result in some kind of heat dissipation and that theoretically, with reversible operations, if operation A pushes the machine from an original state into some new state, then operation A$^{-1}$ could use the already existing energy in the system to push it back to the original state.
Such a machine has not yet been invented, but reversible programming has other interesting properties.
As discussed in section \ref{chapt - Concept of reversible computing}, it can serve as protection against side-channel attacks and is also an interesting field to study to better understand quantum computing.

\section{Basis for the work}
This goal of this thesis is to further extend Hermes, which is a reversible programming language developed at DIKU.
Hermes is based on the reversible programming language Janus and designed specifically for writing encryption algorithms [5].
By virtue of some carefully thought-out design choices, Hermes offers a built-in protection against some side-channel attacks.

In the current implementation, Hermes programs are translated to C by the program \emph{hc} and then to assembly code with the GNU Compiler Collection (gcc). The gcc compiler does not prevent side-channel attacks per default, but one can use zerostack [1] to zero out the stack and registers of sensitive functions.
There is also the problem of timing attacks introduced by gcc [2].
This compilation from Hermes to assembly is a two-step process with a required extra check by zerostack. But with embedded systems being the focus of these reversible lightweight cryptography algorithms, it seems appropriate with a compiler that translates Hermes directly to ARM assembly code.


%[1] \href{https://github.com/lmrs2/zerostack}{zerostack: Zeroing stack and registers of sensitive functions. Github project by lmrs2} \\
%
%\noindent [2] \href{https://drive.google.com/file/d/1jsOolD1C\_Fu9oNVvhkB1\_RQ9GlrFSGcN}{David Chisnall, Laurent Simon, Ross Anderson. What you get is what you C: Controlling side effects in mainstream C compilers} \\
%
%\noindent [3] Chris Lutz, Howard Derby. B. Parser, and JANUS Language Syntax JANUS : A TIME-REVERSIBLE LANGUAGE A . Lexical Analyzer. pages 1–4, 1986. \\
%
%\noindent [4] Tetsuo Yokoyama, Holger Bock Axelsen, and Robert Glück. Principles of a reversible programming language. In Proceedings of the 2008 conference on Computing frontiers - CF ’08, 2008. \\
%
%\noindent [5] Torben Ægidius Mogensen. Hermes: A Language for Writing Encryption Algorithms.
